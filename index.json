[{"authors":null,"categories":null,"content":"I am a professor of hydraulic engineering at the University of Rijeka (UNIRI), Faculty of Civil Engineering, in Rijeka, Croatia. Over the last several years, I have been researching buoyancy driven flows, specifically, the saltwater and freshwater exchange in stratified estuaries.\nMy current research interests lie in advanced hydraulic modelling in coastal areas. I am focused on understanding and predicting compound events, especially those caused by high sea levels, such as flooding in coastal regions or increased salinity intrusions along coastal rivers. My interests also include nature-based solutions and sustainable urbane drainge systems.\nIn 2020 I became the head of the Laboratory for Hybrid Computational Methods at the Center for Artificial Intelligence and Cybersecurity (AIRI), where we are developing new computational methods that combine physically based models with machine learning to solve complex problems in hydrological, hydraulic and coastal engineering.\nIn those small gaps of free time between teaching, coding and writing, you may find me in the woods surrounding Rijeka playing Disc golf.\n  My CV is available for more information.\nPlease feel free to contact me if you have questions or if you are interested in collaborating.\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://nkrvavica.github.io/author/nino-krvavica/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/nino-krvavica/","section":"authors","summary":"I am a professor of hydraulic engineering at the University of Rijeka (UNIRI), Faculty of Civil Engineering, in Rijeka, Croatia. Over the last several years, I have been researching buoyancy driven flows, specifically, the saltwater and freshwater exchange in stratified estuaries.","tags":null,"title":"Nino Krvavica","type":"authors"},{"authors":null,"categories":null,"content":"   Table of Contents  What you will learn Program overview Courses in this program Meet your instructor FAQs    What you will learn  Fundamental Python programming skills Statistical concepts and how to apply them in practice Gain experience with the Scikit, including data visualization with Plotly and data wrangling with Pandas  Program overview The demand for skilled data science practitioners is rapidly growing. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi.\nCourses in this program  Python basics Build a foundation in Python.   Visualization Learn how to visualize data with Plotly.   Statistics Introduction to statistics for data science.   Meet your instructor Nino Krvavica FAQs Are there prerequisites? There are no prerequisites for the first course.\n How often do the courses run? Continuously, at your own pace.\n  Begin the course   ","date":1611446400,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1611446400,"objectID":"59c3ce8e202293146a8a934d37a4070b","permalink":"https://nkrvavica.github.io/courses/example/","publishdate":"2021-01-24T00:00:00Z","relpermalink":"/courses/example/","section":"courses","summary":"An example of using Wowchemy's Book layout for publishing online courses.","tags":null,"title":"📊 Learn Data Science","type":"book"},{"authors":null,"categories":null,"content":"Build a foundation in Python.\n  1-2 hours per week, for 8 weeks\nLearn   Quiz What is the difference between lists and tuples? Lists\n Lists are mutable - they can be changed Slower than tuples Syntax: a_list = [1, 2.0, 'Hello world']  Tuples\n Tuples are immutable - they can\u0026rsquo;t be changed Tuples are faster than lists Syntax: a_tuple = (1, 2.0, 'Hello world')   Is Python case-sensitive? Yes\n","date":1609459200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1609459200,"objectID":"17a31b92253d299002593b7491eedeea","permalink":"https://nkrvavica.github.io/courses/example/python/","publishdate":"2021-01-01T00:00:00Z","relpermalink":"/courses/example/python/","section":"courses","summary":"Build a foundation in Python.\n","tags":null,"title":"Python basics","type":"book"},{"authors":null,"categories":null,"content":"Learn how to visualize data with Plotly.\n  1-2 hours per week, for 8 weeks\nLearn   Quiz When is a heatmap useful? Lorem ipsum dolor sit amet, consectetur adipiscing elit.\n Write Plotly code to render a bar chart import plotly.express as px data_canada = px.data.gapminder().query(\u0026quot;country == 'Canada'\u0026quot;) fig = px.bar(data_canada, x='year', y='pop') fig.show()  ","date":1609459200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1609459200,"objectID":"1b341b3479c8c6b1f807553b77e21b7c","permalink":"https://nkrvavica.github.io/courses/example/visualization/","publishdate":"2021-01-01T00:00:00Z","relpermalink":"/courses/example/visualization/","section":"courses","summary":"Learn how to visualize data with Plotly.\n","tags":null,"title":"Visualization","type":"book"},{"authors":null,"categories":null,"content":"Introduction to statistics for data science.\n  1-2 hours per week, for 8 weeks\nLearn The general form of the normal probability density function is:\n$$ f(x) = \\frac{1}{\\sigma \\sqrt{2\\pi} } e^{-\\frac{1}{2}\\left(\\frac{x-\\mu}{\\sigma}\\right)^2} $$\n The parameter $\\mu$ is the mean or expectation of the distribution. $\\sigma$ is its standard deviation. The variance of the distribution is $\\sigma^{2}$.   Quiz What is the parameter $\\mu$? The parameter $\\mu$ is the mean or expectation of the distribution.\n","date":1609459200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1609459200,"objectID":"6f4078728d71b1b791d39f218bf2bdb1","permalink":"https://nkrvavica.github.io/courses/example/stats/","publishdate":"2021-01-01T00:00:00Z","relpermalink":"/courses/example/stats/","section":"courses","summary":"Introduction to statistics for data science.\n","tags":null,"title":"Statistics","type":"book"},{"authors":null,"categories":null,"content":"Project nr.: ZIP-UNIRI-1500-1-20.\nProject duration: December, 2020 - December, 2022\nLead researcher: Nino Krvavica, PhD\nEstuaries are transitional areas between river and marine environments. Understanding the estuarine dynamics is important for various water management issues, such as predicting floods and droughts, assessing impacts of sea level rise, planning freshwater intake for irrigation, and managing sediment transport. One of the key requirements for understanding and predicting the estuarine dynamics is to have reliable river discharge data. Current approaches for estimating discharges in tidally affected river reaches have limitations and new concepts and computational methods are needed. Therefore, the main objective of this research is to develop a suitable computational method for estimating river discharges in highly stratified estuaries from field measurements. The pilot area will be the Neretva River estuary, the largest river in the eastern part of the Adriatic Basin. The methodology consists of data processing, signal analysis, numerical modelling, and development of a hybrid computational approach, which combines physically based models with machine learning methods. The project team will be established at the University of Rijeka, Faculty of Civil Engineering, and it will consist of experts in hydrology, coastal engineering, signal processing and machine learning. The team will be led by Nino Krvavica, an expert in estuarine hydrodynamics. The expected result and main scientific contribution from this research will be a methodology for estimating river discharges in highly stratified estuaries from known water stages and sea levels. Once the method is thoroughly tested and validated in the Neretva River, it could be applied to other coastal rivers in Croatia and implemented as a part of a national hydrological monitoring programme.\n","date":1606780800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1606780800,"objectID":"95a397e5a78aea9fac598ddc1b4bb894","permalink":"https://nkrvavica.github.io/project/uniri_zip_2020-2022/","publishdate":"2020-12-01T00:00:00Z","relpermalink":"/project/uniri_zip_2020-2022/","section":"project","summary":"Funding of Scientific Research Projects (ZIP UNIRI)","tags":["estuaries","hydraulic modelling","machine learning","hydrological measurements","sea levels","river discharges"],"title":"Estimating River Discharges in Highly Stratified Estuaries","type":"project"},{"authors":["Nino Krvavica","Josip Rubinić"],"categories":null,"content":"","date":1595023200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595023200,"objectID":"5c6b8f8e04400fac5bf47384ae652bcc","permalink":"https://nkrvavica.github.io/publication/krvavica-2020-novigrad/","publishdate":"2020-07-18T00:00:00+02:00","relpermalink":"/publication/krvavica-2020-novigrad/","section":"publication","summary":"This study investigates and compares several design storms for flood estimation in partially urbanized catchments. Six different design storms were considered: Euler II, Alternating Block Method, Average Variability Method, Huff's curves, and uniform rainfall. Additionally, two extreme historical storms have been included for comparison. A small, ungauged, partially urbanized catchment in Novigrad (Croatia) was chosen as a study area to account for the infiltration impact on the rainfall-runoff process. The performance of each design storm was assessed based on the flood modelling results, namely the water depth, water velocity, flow rate, and overall flood extent. Also, several rainfall durations were considered to identify a critical scenario. The excess rainfall was computed using the Soil Conservation Service's Curve Number method, and two-dimensional flooding simulations were performed by the HEC-RAS model. The results confirmed that the choice of the design storm and the rainfall duration have a significant impact on the flood modelling results. Overall, design storms constructed only from IDF curves overestimated flooding in comparison to historical events, whereas design storms derived from the analysis of observed temporal patterns matched or slightly underestimated the flooding results. Of the six considered design storms, the Average Variability Method showed the closest agreement with historical storms.","tags":null,"title":"Evaluation of Design Storms and Critical Rainfall Durations for Flood Prediction in Partially Urbanized Catchments","type":"publication"},{"authors":null,"categories":null,"content":"Iterview for Stilueta In March 2020 I gave an interview for an online magazine Stilueta, where I talked about my scientific work, life as a scientist, my background, and free time.\n","date":1586476800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1586476800,"objectID":"b93ebf6d80f976a96f5ab6b42fd60b65","permalink":"https://nkrvavica.github.io/talk/interview-for-an-online-magazine-stilueta/","publishdate":"2020-04-10T00:00:00Z","relpermalink":"/talk/interview-for-an-online-magazine-stilueta/","section":"event","summary":"In March 2020 I gave an interview for an online magazine Stilueta.","tags":["science","magazine","interview"],"title":"Interview for an online magazine Stilueta","type":"event"},{"authors":["Nino Krvavica","Gabrijel Peroli","Igor Ružić","Nevenka Ožanić"],"categories":null,"content":"","date":1586383200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1586383200,"objectID":"d44cb47d8a45f3a4d9517d229f16a6c1","permalink":"https://nkrvavica.github.io/publication/krvavica-2020-seaorgan/","publishdate":"2020-04-09T00:00:00+02:00","relpermalink":"/publication/krvavica-2020-seaorgan/","section":"publication","summary":"This paper presents a one-dimensional time-dependent numerical model of a sea organ, which generates music driven by the motion of the sea. The governing equations are derived by coupling hydrodynamic and thermodynamic equations for water level and air pressure oscillations in a sea organ pipe system forced by irregular waves. The model was validated by comparing numerical results to experimental data obtained from a scaled physical model. Furthermore, the model’s capabilities are presented by simulating internal oscillations in the Sea Organ in Zadar, Croatia. The response of the Sea Organ varies between segments and for different wave conditions. The strongest air pressure and water level response is found near resonance frequencies.","tags":null,"title":"Time-dependent numerical model for simulating internal oscillations in a sea organ","type":"publication"},{"authors":["Nino Krvavica","Igor Ružić"],"categories":null,"content":"","date":1581116400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1581116400,"objectID":"1af342ff9c10ba7d16a5266ed44e117a","permalink":"https://nkrvavica.github.io/publication/krvavica-2020-sealevelrise/","publishdate":"2020-02-08T00:00:00+01:00","relpermalink":"/publication/krvavica-2020-sealevelrise/","section":"publication","summary":"Understanding the response of estuaries to sea-level rise is crucial in developing a suitable mitigation and climate change adaptation strategy. This study investigates the impacts of rising sea levels on salinity intrusion in salt-wedge estuaries. The sea-level rise impacts are assessed in idealized estuaries using simple expressions derived from a two-layer hydraulic theory, and in the Neretva River Estuary in Croatia using a two-layer time-dependent model. The assessment is based on three indicators — the salt-wedge intrusion length, the seawater volume, and the river inflows needed to restore the baseline intrusion. The potential SLR was found to increase all three considered indicators. Theoretical analysis in idealized estuaries suggests that shallower estuaries are more sensitive to SLR. Numerical results for the Neretva River Estuary showed that SLR may increase salt-wedge intrusion length, volume, and corrective river inflow. However, the results are highly non-linear because of the channel geometry, especially for lower river inflows. A theoretical assessment of channel bed slope impacts on limiting a potential intrusion is therefore additionally discussed. This findings emphasize the need to use several different indicators when assessing SLR impacts.","tags":null,"title":"Assessment of sea-level rise impacts on salt-wedge intrusion in idealized and Neretva River Estuary","type":"publication"},{"authors":null,"categories":null,"content":"Iterview for radio Rijeka In the January of 2020 I gave an interview for a local radio station Rijeka, and I talked about my scientific work, current research and future plans.\n","date":1578857400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1578857400,"objectID":"b47ef754bf8609a4659c83e28d3130d3","permalink":"https://nkrvavica.github.io/talk/scientific-talk-for-the-radio-rijeka/","publishdate":"2020-01-12T19:30:00Z","relpermalink":"/talk/scientific-talk-for-the-radio-rijeka/","section":"event","summary":"In the January of 2020 I gave an [interview](https://radio.hrt.hr/radio-rijeka/ep/nino-krvavica-rjecina-kao-model/328526/ ) for a local radio station Rijeka, and I talked about my scientific work, received awards, current research, and future plans.","tags":["science","radio","interview"],"title":"Scientific talk for the Radio Rijeka","type":"event"},{"authors":["Nino Krvavica"],"categories":null,"content":"","date":1577833200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577833200,"objectID":"2ebeb7b0b996c2b6edc0371bcdd24a4e","permalink":"https://nkrvavica.github.io/publication/krvavica-2020-reevaluating/","publishdate":"2020-01-01T00:00:00+01:00","relpermalink":"/publication/krvavica-2020-reevaluating/","section":"publication","summary":"","tags":null,"title":"Re-evaluating efficiency of first-order numerical schemes for two-layer shallow water systems by considering different eigenvalue solutions","type":"publication"},{"authors":null,"categories":null,"content":"In December 2019, I received an award from Scientific Foundation for the best scientist at the University of Rijeka for 2018 in technical and biotechnical sciences.\n","date":1576281600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1576281600,"objectID":"c85ba191e0322aeffea102953794d390","permalink":"https://nkrvavica.github.io/talk/award-for-the-best-scientist-at-the-university-of-rijeka-in-2018-in-technical-and-biotechnical-sciences/","publishdate":"2019-12-14T00:00:00Z","relpermalink":"/talk/award-for-the-best-scientist-at-the-university-of-rijeka-in-2018-in-technical-and-biotechnical-sciences/","section":"event","summary":"Received an award from Scientific Foundation of University of Rijeka for the best scientist at the University of Rijeka for 2018 in technical and biotechnical sciences","tags":["science","award","uniri"],"title":"Award for the best scientist at the University of Rijeka in 2018 in technical and biotechnical sciences","type":"event"},{"authors":null,"categories":null,"content":"BEACHEX\nSUSTAINABLE CONSTRUCTION OF ARTIFICIAL GRAVEL BEACHES-CONSTRUCTION OF NEW BEACHES AND AN INCREASE OF EXISTING CAPACITY\nProject duration: 2019 - 2023\nLead researcher: Dalibor Carević, PhD\nProject [homepage] (http://grad.hr/beachex/en/)\nAbout Beachex Croatia’s gravel beaches are under immense pressure from the rapidly growing tourist industry that requires an increase in existing beach capacity by beach nourishment while at the same time the beaches are under the influence of increased storm activity as a consequence of climate change. The Beachex project aims to explore the mechanisms of gravel beach erosion and recovery to provide technical support for long-term beach nourishment in order to achieve a sustainable increase in beach capacity while reducing the influence of climate change.\n","date":1575158400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1575158400,"objectID":"10a5a628251bfd7b15372cf8cf073326","permalink":"https://nkrvavica.github.io/project/beachex_2019-23/","publishdate":"2019-12-01T00:00:00Z","relpermalink":"/project/beachex_2019-23/","section":"project","summary":"Cooperation Programme with Croatian Scientists in Diaspora 'RESEARCH COOPERABILITY'","tags":["numerical modeling","waves","sediment transport","coastal areas"],"title":"Sustainable Construction of Artificial Gravel Beaches-Construction of New Beaches and an Increase Of Existing Capacity","type":"project"},{"authors":["Igor Ružić","Sanja Dugonjić Jovančević","Čedomir Benac","Nino Krvavica"],"categories":null,"content":"","date":1575154800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1575154800,"objectID":"0914390f7c4dd3aed88a4766a3a7694f","permalink":"https://nkrvavica.github.io/publication/ruvzic-2019-geosciences/","publishdate":"2019-12-01T00:00:00+01:00","relpermalink":"/publication/ruvzic-2019-geosciences/","section":"publication","summary":"","tags":null,"title":"Assessment of the Coastal Vulnerability Index in an Area of Complex Geological Conditions on the Krk Island, Northeast Adriatic Sea","type":"publication"},{"authors":[],"categories":[],"content":"Create slides in Markdown with Wowchemy Wowchemy | Documentation\n Features  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides   Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export: E   Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026quot;blueberry\u0026quot; if porridge == \u0026quot;blueberry\u0026quot;: print(\u0026quot;Eating...\u0026quot;)   Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = ;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\n Fragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}} {{% fragment %}} **Two** {{% /fragment %}} {{% fragment %}} Three {{% /fragment %}}  Press Space to play!\nOne  Two  Three \n A fragment can accept two optional parameters:\n class: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears   Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}} - Only the speaker can read these notes - Press `S` key to view {{% /speaker_note %}}  Press the S key to view the speaker notes!\n Only the speaker can read these notes Press S key to view    Themes  black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links    night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links   Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026quot;/media/boards.jpg\u0026quot; \u0026gt;}} {{\u0026lt; slide background-color=\u0026quot;#0000FF\u0026quot; \u0026gt;}} {{\u0026lt; slide class=\u0026quot;my-style\u0026quot; \u0026gt;}}   Custom CSS Example Let\u0026rsquo;s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1, .reveal section h2, .reveal section h3 { color: navy; }   Questions? Ask\nDocumentation\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"0e6de1a61aa83269ff13324f3167c1a9","permalink":"https://nkrvavica.github.io/slides/example/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/example/","section":"slides","summary":"An introduction to using Wowchemy's Slides feature.","tags":[],"title":"Slides","type":"slides"},{"authors":null,"categories":null,"content":"Summary This document examines various ways to compute roots of cubic (3rd order polynomial) and quartic (4th order polynomial) equations in Python. First, two numerical algorithms, available from Numpy package (roots and linalg.eigvals), were analyzed. Then, an optimized closed-form analytical solutions to cubic and quartic equations were implemented and examined. Finally, the analytical solutions were vectorized by using numpy arrays in order to avoid slow python iterations when multiple polynomials are solved. All these functions were evaluated by comparing their computational speeds. Analytical cubic and quartic solvers were one order of magnitude faster than both numerical Numpy functions for a single polynomial. When a large set of polynomials were given as input, the vectorized analytical solver outperformed the numerical Numpy functions by one and two orders of magnitude, respectively.\nIntroduction In scientific computing we are sometimes faced with solving roots of a cubic (3rd order polynomial) or quartic equation (4th order polynomial) to get crucial information about the characteristics of some physical process or to develop an appropriate numerical scheme. These issues are regularly encountered when analyzing coupled dynamic systems described by three or four differential equations. One such example is a two-layer Shallow Water Flow (SWE), which is defined by four Partial Differential Equations (PDE). In two-layer SWE, the eigenvalues of the 4x4 flux matrix describe the speed of internal and external wave propagation. And, the eigenvalues correspond to roots of a characteristic 4th order polynomial. Similarly, SWE coupled with sediment transport are defined by three PDEs. In this case, the eigenvalues of a 3x3 matrix correspond to roots of a characteristic 3rd order polynomial. There are many more examples where such computation is required.\nRoots of cubic and quartic equations can be computed using numerical methods or analytical expressions (so called closed-form solutions). Numerical methods are based on specific algorithms and provide only approximations to roots. Root-finding algorithms (such as Newton\u0026rsquo;s, secant, Brent\u0026rsquo;s method, etc.) are appropriate for any continuous function, they use iterations but do not guarantee that all roots will be found. However, a different class of numerical methods is available (and recommended) for polynomials, based on finding eigenvalues of the companion matrix of a polynomial.\nIn Python, there are several ways to numerically compute roots of any polynomial; however, only two functions are generally recommended and used. First is a Numpy function called roots which directly computes all roots of a general polynomial, and the second is also a Numpy function from linalg module called eigvals, which computes eigenvalues of a companion matrix constructed from a given (characteristic) polynomial.\nOn the other hand, analytical closed-form solutions exist for all polynomials of degree lower than five, that is, for quadratic, cubic, and quartic equations. Although, the expressions for cubic and quadratic roots are longer and more complicated than for a quadratic equations, they can still be easily implemented in some computational algorithm. The closed-form solution for roots of cubic equations is based on Cardano\u0026rsquo;s expressions given here and here. Similarly, solution to the roots for quartic equations is based on Ferrari\u0026rsquo;s expressions given here and here. A fast and optimized algorithm - FQS - that uses analytical solutions to cubic and quartic equation was implemented in Python and made publicly available here.\nAll computational algorithms were implemented in Python 3.7 with Numpy 1.15, and tests were done on Windows 64-bit machine, i5-2500 CPU @ 3.30 GHz.\nNumerical algorithms Function numpy.roots Function numpy.roots can compute roots of a general polynomial defined by a list of its coefficients p.\nFor cubic equations, p is defined as:\np[0]*x**3 + p[1]*x**2 + p[2]*x + p[3],\r and for quartic equations, p is defined as:\np[0]*x**4 + p[1]*x**3 + p[2]*x**2 + p[3]*x + p[4].\r The function to compute roots of a single polynomial is implemented for cubic roots as follows:\nimport numpy\rp_cubic = numpy.random.rand(4)\rcubic_roots = numpy.roots(p_cubic)\r and for quartic roots:\np_quartic = numpy.random.rand(5)\rquartic_roots = numpy.roots(p_quartic)\r The respective results are:\n\u0026gt;\u0026gt;\u0026gt; p_cubic\rarray([0.21129527, 0.23589228, 0.73094489, 0.84747689])\r\u0026gt;\u0026gt;\u0026gt; cubic_roots\rarray([ 0.01557778+1.86945535j, 0.01557778-1.86945535j,\r-1.1475662 +0.j ]))\r and\n\u0026gt;\u0026gt;\u0026gt; p_quartic\rarray([0.30022249, 0.31473263, 0.00791689, 0.06335546, 0.73838408])\r\u0026gt;\u0026gt;\u0026gt; quartic_roots\rarray([-1.19538943+0.7660177j , -1.19538943-0.7660177j ,\r0.67122379+0.87725993j, 0.67122379-0.87725993j])\r Let\u0026rsquo;s look at the computation times using timeit function:\nimport timeit\r%timeit numpy.roots(p_cubic)\r76.5 µs ± 148 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)\r%timeit numpy.roots(p_quartic)\r80.1 µs ± 2.98 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)\r This may seem quite fast; however, what if we need to solve, let\u0026rsquo;s say, 10 000 polynomials:\np_cubics = numpy.random.rand(10_000, 4)\rp_quartics = numpy.random.rand(10_000, 5)\r Notice that numpy.roots takes only rank-1 arrays, which means that we have to use for loops or list comprehensions. The latter, are usually faster in python (and more pythonish), therefore we write:\ncubic_roots = [numpy.roots(pi) for pi in p_cubics]\rquartic_roots = [numpy.roots(pi) for pi in p_quartics]\r Their corresponding computation times:\n%timeit [numpy.roots(pi) for pi in p_cubics]\r786 ms ± 15.6 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\r%timeit [numpy.roots(pi) for pi in p_quartics]\r795 ms ± 2.51 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\r It seems that it takes 10 000 times longer to compute 10 000 polynomials than 1 polynomial.\nCan we speed things up, knowing that loops in Python are slower in comparison to other high level languages, such as C/C++ or FORTRAN?\nFunction numpy.linalg.eigvals Documentation for numpy.roots states that its algorithms rely on computing the eigenvalues of the companion matrix. It uses the fact that the eigenvalues of a matrix A are the roots of its characteristic polynomial p.\nFunction numpy.linalg.eigvals computes eigenvalues of a general square matrix A using geev LAPACK routines. The main advantage of the function linalg.eigvals over roots is that it uses vectorization. Meaning, it runs certain operations over entire array, rather than over individual elements. Therefore, it can take as input stacked array of companion matrices, and does not require for loops or list comprehensions.\nFor cubic equations, first we reduce the polynomial to the form:\nx**3 + a*x**2 +b*x + c = 0,\r and then construct the companion matrix:\nA = [[0, 0, -c],\r[1, 0, -b],\r[0, 1, -a]]\r For quartic equations, we reduce the polynomial to the form:\nx**4 + a*x**3 + b*x**2 +c*x + d = 0,\r and then construct the companion matrix:\nA = [[0, 0, 0, -d],\r[1, 0, 0, -c],\r[0, 1, 0, -b],\r[0, 0, 1, -a]]\r The function to compute roots from eigenvalues of a single companion matrix is implemented for cubic equation as follows:\ndef eig_cubic_roots(p):\r# Coefficients of quartic equation\ra, b, c = p[:, 1]/p[:, 0], p[:, 2]/p[:, 0], p[:, 3]/p[:, 0]\r# Construct the companion matrix\rA = numpy.zeros((len(a), 3, 3))\rA[:, 1:, :2] = numpy.eye(2)\rA[:, :, 2] = -numpy.array([c, b, a]).T\r# Compute roots using eigenvalues\rreturn numpy.linalg.eigvals(A)\r Similarly, for quartic equation:\ndef eig_quartic_roots(p):\r# Coefficients of quartic equation\ra, b, c, d = (p[:, 1]/p[:, 0], p[:, 2]/p[:, 0],\rp[:, 3]/p[:, 0], p[:, 4]/p[:, 0])\r# Construct the companion matrix\rA = numpy.zeros((len(a), 4, 4))\rA[:, 1:, :3] = numpy.eye(3)\rA[:, :, 3] = -numpy.array([d, c, b, a]).T\r# Compute roots using eigenvalues\rreturn numpy.linalg.eigvals(A)\r To compute roots of a single cubic equation, eigvals is implemented as follows:\ncubic_roots = eig_cubic_roots(p_cubic[None, :])\r and for quartic roots:\nquartic_roots = eig_quartic_roots(p_quartic[None, :])\r The results are:\n\u0026gt;\u0026gt;\u0026gt; cubic_roots\rarray([[-1.1475662 +0.j , 0.01557778+1.86945535j,\r0.01557778-1.86945535j]])\r and\n\u0026gt;\u0026gt;\u0026gt; quartic_roots\rarray([[ 0.67122379+0.87725993j, 0.67122379-0.87725993j,\r-1.19538943+0.7660177j , -1.19538943-0.7660177j ]])\r Let\u0026rsquo;s look at the computation times:\n%timeit eig_cubic_roots(p_cubic[None, :])\r67 µs ± 316 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)\r%timeit eig_quartic_roots(p_quartic[None, :])\r69.3 µs ± 135 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)\r The computation times are slightly faster than numpy.roots.\nLet see the difference for 10 000 polynomials:\n%timeit eig_cubic_roots(p_cubics)\r31.2 ms ± 1.05 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)\r%timeit eig_quartic_roots(p_quartics)\r48.3 ms ± 48.6 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)\r The results indicate that numpy.linalg.eigvals is one order of magnitude faster than numpy.roots, and that is a huge gain.\nWhat about analytical solutions to cubic and quartic equations? Implementation for a single polynomial Now, let\u0026rsquo;s look at analytical implementations available by FQS function. First, implementation of analytical solutions for single quadratic, cubic and quartic equation is presented. As stated in the introduction, these algorithms are based on closed-form solutions for cubic (given here and here) and quartic equations (given here and here). These equations were modified to avoid repeating computations.\nPython function for roots of a quadratic equation is implemented as:\nimport math, cmath\rdef single_quadratic(a0, b0, c0):\r''' Reduce the quadratic equation to to form:\rx**2 + a*x + b = 0 '''\ra, b = b0 / a0, c0 / a0\r# Some repeating variables\ra0 = -0.5*a\rdelta = a0*a0 - b\rsqrt_delta = cmath.sqrt(delta)\r# Roots\rr1 = a0 - sqrt_delta\rr2 = a0 + sqrt_delta\rreturn r1, r2\r The function for roots of a cubic equation is implemented as:\ndef single_cubic(a0, b0, c0, d0):\r''' Reduce the cubic equation to to form:\rx**3 + a*x**2 + b*x + c = 0 '''\ra, b, c = b0 / a0, c0 / a0, d0 / a0\r# Some repeating constants and variables\rthird = 1./3.\ra13 = a*third\ra2 = a13*a13\rsqr3 = math.sqrt(3)\r# Additional intermediate variables\rf = third*b - a2\rg = a13 * (2*a2 - b) + c\rh = 0.25*g*g + f*f*f\rdef cubic_root(x):\r''' Compute cubic root of a number while maintaining its sign'''\rif x.real \u0026gt;= 0:\rreturn x**third\relse:\rreturn -(-x)**third\rif f == g == h == 0:\rr1 = -cubic_root(c)\rreturn r1, r1, r1\relif h \u0026lt;= 0:\rj = math.sqrt(-f)\rk = math.acos(-0.5*g / (j*j*j))\rm = math.cos(third*k)\rn = sqr3 * math.sin(third*k)\rr1 = 2*j*m - a13\rr2 = -j * (m + n) - a13\rr3 = -j * (m - n) - a13\rreturn r1, r2, r3\relse:\rsqrt_h = cmath.sqrt(h)\rS = cubic_root(-0.5*g + sqrt_h)\rU = cubic_root(-0.5*g - sqrt_h)\rS_plus_U = S + U\rS_minus_U = S - U\rr1 = S_plus_U - a13\rr2 = -0.5*S_plus_U - a13 + S_minus_U*sqr3*0.5j\rr3 = -0.5*S_plus_U - a13 - S_minus_U*sqr3*0.5j\rreturn r1, r2, r3\r And finally, the function for roots of a quartic equation is implemented as:\ndef single_quartic(a0, b0, c0, d0, e0):\r''' Reduce the quartic equation to to form:\rx**4 + a*x**3 + b*x**2 + c*x + d = 0'''\ra, b, c, d = b0/a0, c0/a0, d0/a0, e0/a0\r# Some repeating variables\ra0 = 0.25*a\ra02 = a0*a0\r# Coefficients of subsidiary cubic equation\rp = 3*a02 - 0.5*b\rq = a*a02 - b*a0 + 0.5*c\rr = 3*a02*a02 - b*a02 + c*a0 - d\r# One root of the cubic equation\rz0, _, _ = single_cubic(1, p, r, p*r - 0.5*q*q)\r# Additional variables\rs = cmath.sqrt(2*p + 2*z0.real + 0j)\rif s == 0:\rt = z0*z0 + r\relse:\rt = -q / s\r# Compute roots by quadratic equations\rr0, r1 = single_quadratic(1, s, z0 + t)\rr2, r3 = single_quadratic(1, -s, z0 - t)\rreturn r0 - a0, r1 - a0, r2 - a0, r3 - a0\r Notice that the quartic solution calls both cubic and quadratic functions.\nFor a single cubic equation, the results are:\n\u0026gt;\u0026gt;\u0026gt; single_cubic(*p_cubic)\r((-1.147566194142574+0j),\r(0.01557779507848811+1.8694553386446031j),\r(0.01557779507848811-1.8694553386446031j))\r and for a quartic:\n\u0026gt;\u0026gt;\u0026gt; single_quartic(*p_quartic)\r((-1.195389428644198+0.766017693855147j),\r(-1.195389428644198-0.766017693855147j),\r(0.6712237840251022+0.8772599258280781j),\r(0.6712237840251022-0.8772599258280781j))\r Let\u0026rsquo;s look at the computation times:\n%timeit single_cubic(*p_cubic)\r28.6 µs ± 604 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)\r%timeit single_quartic(*p_quartic)\r50.3 µs ± 636 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)\r We can notice that single_cubic is twice as fast than both numerical solvers implemented in Numpy. Whereas, single_quartic is about 30-40% faster than the numerical solvers.\nWhat about multiple polynomials?\n%timeit [single_cubic(*pi) for pi in p_cubics]\r236 ms ± 7.89 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\r%timeit [single_quartic(*pi) for pi in p_quartics]\r421 ms ± 1.84 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\r Analytical closed-form solver is about twice as fast than numpy.roots. However, it is much slower (almost one order of magnitude) than the numerical solver from numpy.linalg.eigvals. This difference is mainly the consequence of using list comprehension.\nJust-in-time compiler from Numba Let\u0026rsquo;s see if we can speed up the computation by using just-in-time compiler from Numba. We only need to import it and put a decorator before each function:\nfrom numba import jit\r@jit(nopython=True)\rdef single_quadratic(a0, b0, c0):\r...\r@jit(nopython=True)\rdef single_cubic(a0, b0, c0, d0):\r...\r@jit(nopython=True)\rdef single_quartic(a0, b0, c0, d0, e0):\r...\r These are new computation times after Numba was implemented:\n%timeit single_cubic(*p_cubic)\r6.34 µs ± 7.75 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)\r%timeit single_quartic(*p_quartic)\r5.8 µs ± 6.87 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)\r We can notice that the algorithms are several times faster than both numerical solvers implemented in Numpy.\nWhat about multiple polynomials?\n%timeit [single_cubic(*pi) for pi in p_cubics]\r27.6 ms ± 80.5 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)\r%timeit [single_quartic(*pi) for pi in p_quartics]\r30.8 ms ± 90.6 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)\r Analytical closed-form solver (with Numba) is one order of magnitude faster than numpy.roots and shows similar performance, but slightly faster, than numerical solver from numpy.linalg.eigvals.\nHowever, notice that list comprehensions were used here for multiple inputs. What if we could vectorize this code using Numpy arrays and speed up computation times even more?\nVectorized analytical closed-form solvers To vectorize functions single_quadratic, single_cubic, and single_quartic using Numpy arrays we have to get rid of all if clauses and replace them with Numpy masks. Also, we have to replace all mathematical functions from math and cmath with corresponding Numpy functions. This is implemented as follows.\nFor quadratic equation:\ndef multi_quadratic(a0, b0, c0):\r# Quadratic coefficient\ra, b = b0 / a0, c0 / a0\r# Some repeating variables\ra0 = -0.5*a\rdelta = a0*a0 - b\rsqrt_delta = numpy.sqrt(delta + 0j)\r# Roots\rr1 = a0 - sqrt_delta\rr2 = a0 + sqrt_delta\rreturn r1, r2\r For cubic equation:\ndef multi_cubic(a0, b0, c0, d0, all_roots=True):\r# Cubic coefficients\ra, b, c = b0 / a0, c0 / a0, d0 / a0\r# Some repeating constants and variables\rthird = 1./3.\ra13 = a*third\ra2 = a13*a13\rsqr3 = math.sqrt(3)\r# Additional intermediate variables\rf = third*b - a2\rg = a13 * (2*a2 - b) + c\rh = 0.25*g*g + f*f*f\r# Masks for different combinations of roots\rm1 = (f == 0) \u0026amp; (g == 0) \u0026amp; (h == 0) # roots are real and equal\rm2 = (~m1) \u0026amp; (h \u0026lt;= 0) # roots are real and distinct\rm3 = (~m1) \u0026amp; (~m2) # one real root and two complex\rdef cubic_root(x):\r''' Compute cubic root of a number while maintaining its sign\r'''\rroot = numpy.zeros_like(x)\rpositive = (x \u0026gt;= 0)\rnegative = ~positive\rroot[positive] = x[positive]**third\rroot[negative] = -(-x[negative])**third\rreturn root\rdef roots_all_real_equal(c):\r''' Compute cubic roots if all roots are real and equal\r'''\rr1 = -cubic_root(c)\rif all_roots:\rreturn r1, r1, r1\relse:\rreturn r1\rdef roots_all_real_distinct(a13, f, g, h):\r''' Compute cubic roots if all roots are real and distinct\r'''\rj = numpy.sqrt(-f)\rk = numpy.arccos(-0.5*g / (j*j*j))\rm = numpy.cos(third*k)\rr1 = 2*j*m - a13\rif all_roots:\rn = sqr3 * numpy.sin(third*k)\rr2 = -j * (m + n) - a13\rr3 = -j * (m - n) - a13\rreturn r1, r2, r3\relse:\rreturn r1\rdef roots_one_real(a13, g, h):\r''' Compute cubic roots if one root is real and other two are complex\r'''\rsqrt_h = numpy.sqrt(h)\rS = cubic_root(-0.5*g + sqrt_h)\rU = cubic_root(-0.5*g - sqrt_h)\rS_plus_U = S + U\rr1 = S_plus_U - a13\rif all_roots:\rS_minus_U = S - U\rr2 = -0.5*S_plus_U - a13 + S_minus_U*sqr3*0.5j\rr3 = -0.5*S_plus_U - a13 - S_minus_U*sqr3*0.5j\rreturn r1, r2, r3\relse:\rreturn r1\r# Compute roots\rif all_roots:\rroots = numpy.zeros((3, len(a))).astype(complex)\rroots[:, m1] = roots_all_real_equal(c[m1])\rroots[:, m2] = roots_all_real_distinct(a13[m2], f[m2], g[m2], h[m2])\rroots[:, m3] = roots_one_real(a13[m3], g[m3], h[m3])\relse:\rroots = numpy.zeros(len(a))\rroots[m1] = roots_all_real_equal(c[m1])\rroots[m2] = roots_all_real_distinct(a13[m2], f[m2], g[m2], h[m2])\rroots[m3] = roots_one_real(a13[m3], g[m3], h[m3])\rreturn roots\r And for quadratic equation:\ndef multi_quartic(a0, b0, c0, d0, e0):\r# Quartic coefficients\ra, b, c, d = b0/a0, c0/a0, d0/a0, e0/a0\r# Some repeating variables\ra0 = 0.25*a\ra02 = a0*a0\r# Coefficients of subsidiary cubic equation\rp = 3*a02 - 0.5*b\rq = a*a02 - b*a0 + 0.5*c\rr = 3*a02*a02 - b*a02 + c*a0 - d\r# One root of the cubic equation\rz0 = multi_cubic(1, p, r, p*r - 0.5*q*q, all_roots=False)\r# Additional variables\rs = numpy.sqrt(2*p + 2*z0.real + 0j)\rt = numpy.zeros_like(s)\rmask = (s == 0)\rt[mask] = z0[mask]*z0[mask] + r[mask]\rt[~mask] = -q[~mask] / s[~mask]\r# Compute roots by quadratic equations\rr0, r1 = solve_multi_quadratic(1, s, z0 + t) - a0\rr2, r3 = solve_multi_quadratic(1, -s, z0 - t) - a0\rreturn r0, r1, r2, r3\r Let\u0026rsquo;s examine the computation time of vectorized analytical closed-form solvers for a single polynomial:\n%timeit multi_cubic(*p_cubic.T)\r174 µs ± 2.02 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)\r%timeit multi_quartic(*p_quartic.T)\r233 µs ± 4.91 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)\r Clearly, vectorized version for a single polynomial is overkill, and results in slowest computation times.\nBut what about multiple polynomials:\n%timeit multi_cubic(*p_cubics.T)\r3.14 ms ± 13.1 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\r%timeit multi_quartic(*p_quartics.T)\r5.46 ms ± 38.5 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\r The vectorized implementation of analytical solvers is an order of magnitude faster than original analytical implementation, even with just-in-time compiler from Numba. Furthermore, the vectorized implementation is two order of magnitudes faster than the numerical solver roots and also one-order of magnitude faster than linalg.eigvals.\nSummary (TL;DR) Findings on computation speed of different ways to solve cubic and quartic equations in Python can be summarized as follows:\n Two numerical algorithms for finding polynomial roots are available out-of-box from Numpy package (numpy.roots and numpy.linalg.eigvals) Analytical algorithms (closed-form solutions) for solving polynomial roots were implemented in Python (single_cubic/single_quartic for a single polynomial, and vectorized multi_cubic/multi_quartic for multiple polynomials). These functions are available through FQS Both numerical algorithms have similar CPU times for a single polynomial, but for multiple polynomials linalg.eigvals becomes much faster (up to one order of magnitude) Analytical algorithm single_cubic/single_quartic is the fastest when a single polynomial, or a set smaller then 100 polynomials should be solved For single_cubic/single_quartic just-in-time compiler from Numba gives a significant increase in the computational speed Analytical algorithm multi_cubic/multi_quartic is the fastest when a set larger than 100 polynomials is given as input A Python function containing single_cubic , single_quartic, multi_cubic, and multi_quartic, as well as a function than determines what solver should be used in a specific case, is available through FQS.  The CPU times are summarized in the following two tables for different number of polynomials (Nr.) and separately for cubic and quartic equations:\n   Nr. roots linalg.eigvals single_cubic single_cubic(@jit) multi_cubic     1 76.5 µs 67 µs 28.6 µs 6.34 µs 174 µs   100 8.19 ms 0.54 ms 2.11 ms 0.27 ms 0.24 ms   10000 786 ms 31.2 ms 236 ms 27.6 ms 3.14 ms       Nr. roots linalg.eigvals single_quartic single_quartic (@jit) multi_quartic     1 80.1 µs 69.3 µs 50.3 µs 5.8 µs 233 µs   100 8.22 ms 0.59 ms 3.94 ms 0.33 ms 0.34 ms   10000 795 ms 48.3 ms 421 ms 30.8 ms 5.46 ms    ","date":1548028800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1548028800,"objectID":"5a10eb794c049d6a4306983b68184de1","permalink":"https://nkrvavica.github.io/post/on_computing_roots/","publishdate":"2019-01-21T00:00:00Z","relpermalink":"/post/on_computing_roots/","section":"post","summary":"This document examines various ways to compute roots of cubic (3rd order polynomial) and quartic (4th order polynomial) equations in Python. First, two numerical algorithms, available from Numpy package (`roots` and `linalg.eigvals`), were analyzed. Then, an optimized closed-form analytical solutions to cubic and quartic equations were implemented and examined. Finally, the analytical solutions were vectorized by using `numpy` arrays in order to avoid slow python iterations when multiple polynomials are solved. All these functions were evaluated by comparing their computational speeds. Analytical cubic and quartic solvers were one order of magnitude faster than both numerical Numpy functions for a single polynomial. When a large set of polynomials were given as input, the vectorized analytical solver outperformed the numerical Numpy functions by one and two orders of magnitude, respectively. ","tags":["cubic","quartic","python","numpy","polynomial roots","eigenvalues"],"title":"On computing roots of quartic and cubic equations in Python","type":"post"},{"authors":["Nino Krvavica","Miran Tuhtan","Gordan Jelenić"],"categories":null,"content":"","date":1543618800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1543618800,"objectID":"01d8c4b6af59e7f3b485b1cfa8906e18","permalink":"https://nkrvavica.github.io/publication/krvavica-2018-analytical/","publishdate":"2018-12-01T00:00:00+01:00","relpermalink":"/publication/krvavica-2018-analytical/","section":"publication","summary":"","tags":null,"title":"Analytical implementation of Roe solver for two-layer shallow water equations with accurate treatment for loss of hyperbolicity","type":"publication"},{"authors":["Barbara Karleuša","Josip Rubinić","́ Maja Radišić","Nino Krvavica"],"categories":null,"content":"","date":1535752800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1535752800,"objectID":"eea1f389fcbf442a44bc997320bca2b9","permalink":"https://nkrvavica.github.io/publication/karleuvsa-2018-analysis/","publishdate":"2018-09-01T00:00:00+02:00","relpermalink":"/publication/karleuvsa-2018-analysis/","section":"publication","summary":"","tags":null,"title":"Analysis of Climate Change Impact on Water Supply in Northern Istria (Croatia)","type":"publication"},{"authors":["Nino Krvavica","Krešimir Jaredić","́ Josip Rubinić"],"categories":null,"content":"","date":1533074400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1533074400,"objectID":"a53091cdd7893a1dd042097a56ba2d51","permalink":"https://nkrvavica.github.io/publication/krvavica-2018-metodologija/","publishdate":"2018-08-01T00:00:00+02:00","relpermalink":"/publication/krvavica-2018-metodologija/","section":"publication","summary":"","tags":null,"title":"Methodology for defining the design storm for sizing the infiltration system","type":"publication"},{"authors":["Igor Ružić","Čedomir Benac","́ Suzana Ilić","Nino Krvavica"],"categories":null,"content":"","date":1530396000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1530396000,"objectID":"44c5e32bca9efa80b72a4d2a4c88083e","permalink":"https://nkrvavica.github.io/publication/ruvzic-2018-geomorfolovske/","publishdate":"2018-07-01T00:00:00+02:00","relpermalink":"/publication/ruvzic-2018-geomorfolovske/","section":"publication","summary":"","tags":null,"title":"Geomorfološke promjene minijaturnog žala na kršu","type":"publication"},{"authors":["Nino Krvavica","Igor Ružić","́ Nevenka Ožanić"],"categories":null,"content":"","date":1522533600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1522533600,"objectID":"dc4ca9bdee84ecbdb74030491b377bba","permalink":"https://nkrvavica.github.io/publication/krvavica-2018-integrated/","publishdate":"2018-04-01T00:00:00+02:00","relpermalink":"/publication/krvavica-2018-integrated/","section":"publication","summary":"","tags":null,"title":"Integrated computational model for Sea Organ simulation","type":"publication"},{"authors":["Nino Krvavica","Igor Ružić","́ Nevenka Ožanić"],"categories":null,"content":"","date":1514761200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1514761200,"objectID":"3e4fdfe76ec3dc4a18575449a6b855d5","permalink":"https://nkrvavica.github.io/publication/krvavica-2018-new/","publishdate":"2018-01-01T00:00:00+01:00","relpermalink":"/publication/krvavica-2018-new/","section":"publication","summary":"","tags":null,"title":"New approach to flap-type wavemaker equation with wave breaking limit","type":"publication"},{"authors":["Nino Krvavica","Ivica Kožar","Nevenka Ožanić"],"categories":null,"content":"","date":1514761200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1514761200,"objectID":"214ebccd7fbd01f90a4e619e3e04e6f7","permalink":"https://nkrvavica.github.io/publication/krvavica-2018-relevance/","publishdate":"2018-01-01T00:00:00+01:00","relpermalink":"/publication/krvavica-2018-relevance/","section":"publication","summary":"","tags":null,"title":"The relevance of turbulent mixing in estuarine numerical models for two-layer shallow water flow","type":"publication"},{"authors":["Nino Krvavica","Ivica Kožar","Vanja Travaš","Nevenka Ožanić"],"categories":null,"content":"","date":1483225200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1483225200,"objectID":"eea4b85f6686f169484c44d1ca2a2542","permalink":"https://nkrvavica.github.io/publication/krvavica-2017-numerical/","publishdate":"2017-01-01T00:00:00+01:00","relpermalink":"/publication/krvavica-2017-numerical/","section":"publication","summary":"","tags":null,"title":"Numerical modelling of two-layer shallow water flow in microtidal salt-wedge estuaries: Finite volume solver and field validation","type":"publication"},{"authors":null,"categories":null,"content":"Programme for young researchers funded by the University of Rijeka, Croatia\nProject nr.: 17.06.2.1.02.\nProject duration: July, 2018 - July, 2019\nLead researcher: Nino Krvavica, PhD\nProject homepage (in Croatian)\nFloods in coastal areas are occurring more frequently because of climate changes, especially due to more pronounced extreme precipitations and storm surges from the seas. Until now, these two phenomena have been observed separately, and only recently, the interaction between the sea and rivers has begun to be considered as an integral process. In the Republic of Croatia, there are many coastal areas that are exposed to flood hazards equally from the sea and land. However, the processes that take place due to the interaction between freshwater and saltwater in the coastal areas are still not sufficiently examined, especially under sudden flow changes such as flood waves, and in highly stratified conditions characteristic of the Adriatic Sea.\nThe proposed research will focus on an integrated understanding of the dynamics of the saltwater and freshwater under the influence of river flow, tides and waves, as well as floods due to the coincidence of extreme precipitation and storm surges. In addition to hydrodynamic processes, the sediment transport and the corresponding morphological changes in coastal areas will be investigated. This research will be based on specialized numerical models, original mathematical models and field measurements. As part of the field measurement campaigns, the scientific equipment from the laboratory of the Faculty of Civil Engineering will be activated, which was obtained through the project Research infrastructure development at the Campus of the University of Rijeka (RISK).\nThe aim of the proposed research is to carry out extensive flood simulations, including the non-linear interaction between storm surges, sea waves and river flows. For this purpose, a combination of various open-source computer programs will be used. Also, one of the goals is to improve our own numerical model (STREAM) by including: non-steady flow calculation of three layers of different densities, boundary conditions describing realistic waves, and sediment transport. Finally, field measurements aim to measure and better understand mixing intensities and friction on the interface between freshwater and saltwater layers, establish systematic wave measurements in the Bay of Rijeka, and improve the methodology for measuring coastal morphological changes using SfM photogrammetry.\nUnder his project, the research will result in the development of flood forecasting methodology that accounts for the river-sea interaction, in the increase of the existing knowledge on saltwater and freshwater interaction in the coastal area, in the definition of the appropriate wave spectrum for the Bay of Rijeka, and in the open-source STREAM numerical model which will become available to a wider scientific and professional community. In addition, cooperation and partnership with other departments at the University of Rijeka and colleagues from other universities in the country and abroad will be initiated. Finally, the proposed research will intensify the integration of the University of Rijeka into the European research community and stimulate the transfer of knowledge and technology to the business sector.\n","date":1461110400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461110400,"objectID":"675b74f013a203973dd36878af33a5e0","permalink":"https://nkrvavica.github.io/project/uniri_mladi_2018-19/","publishdate":"2016-04-20T00:00:00Z","relpermalink":"/project/uniri_mladi_2018-19/","section":"project","summary":"Programme for young researchers funded by the University of Rijeka, Croatia","tags":["numerical modeling","storm surges","pluvial floods","coastal areas"],"title":"River-Sea Interaction in the Context of Climate Change","type":"project"},{"authors":["Nino Krvavica","Vanja Travaš","Nevenka Ožanić"],"categories":null,"content":"","date":1459461600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1459461600,"objectID":"c34098ade82019cb2d71a640b0293ad5","permalink":"https://nkrvavica.github.io/publication/krvavica-2016-field/","publishdate":"2016-04-01T00:00:00+02:00","relpermalink":"/publication/krvavica-2016-field/","section":"publication","summary":"","tags":null,"title":"A field study of interfacial friction and entrainment in a microtidal salt-wedge estuary","type":"publication"},{"authors":["Nino Krvavica","Vanja Travaš","Nevenka Ožanić"],"categories":null,"content":"","date":1456786800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1456786800,"objectID":"b111282eecdaf8ab514558a0f15e37e9","permalink":"https://nkrvavica.github.io/publication/krvavica-2016-salt/","publishdate":"2016-03-01T00:00:00+01:00","relpermalink":"/publication/krvavica-2016-salt/","section":"publication","summary":"","tags":null,"title":"Salt-Wedge Response to Variable River Flow and Sea-Level Rise in the Microtidal Rječina River Estuary, Croatia","type":"publication"},{"authors":["Nino Krvavica","Igor Ružić","́ Nevenka Ožanić"],"categories":null,"content":"","date":1451602800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1451602800,"objectID":"4f6eec94439b73baaca1988e383c6053","permalink":"https://nkrvavica.github.io/publication/krvavica-2016-analiza/","publishdate":"2016-01-01T00:00:00+01:00","relpermalink":"/publication/krvavica-2016-analiza/","section":"publication","summary":"","tags":null,"title":"Analiza procjene intenziteta oborine pomoću X-band radara","type":"publication"},{"authors":["Vanja Travaš","Nino Krvavica","Josip Rubeša"],"categories":null,"content":"","date":1420066800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1420066800,"objectID":"30d5e9def51ea36f5b8db8df1367fb89","permalink":"https://nkrvavica.github.io/publication/travavs-2015-modelling/","publishdate":"2015-01-01T00:00:00+01:00","relpermalink":"/publication/travavs-2015-modelling/","section":"publication","summary":"","tags":null,"title":"Modelling of the morphology of open river beds for the implementation of a one-dimensional flow analysis","type":"publication"},{"authors":["Nino Krvavica","Vanja Travaš"],"categories":null,"content":"","date":1388530800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1388530800,"objectID":"2f85277274aa4eab954b96dcde730363","permalink":"https://nkrvavica.github.io/publication/krvavica-2014-comparison/","publishdate":"2014-01-01T00:00:00+01:00","relpermalink":"/publication/krvavica-2014-comparison/","section":"publication","summary":"","tags":null,"title":"A comparison of method of characteristics and Preissmann scheme for flood propagation modeling with 1D Saint-Venant equations","type":"publication"},{"authors":["Marjana Gajić-Čapka","́ Nevenka Ožanić","Nino Krvavica"],"categories":null,"content":"","date":1388530800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1388530800,"objectID":"85a2b18f1b157b46f1bdc7cf70448c10","permalink":"https://nkrvavica.github.io/publication/gajic-2014-estimaton/","publishdate":"2014-01-01T00:00:00+01:00","relpermalink":"/publication/gajic-2014-estimaton/","section":"publication","summary":"","tags":null,"title":"Estimaton of maximum short-term precipitation over the Rijeka region","type":"publication"},{"authors":["Vanja Travaš","Nino Krvavica"],"categories":null,"content":"","date":1388530800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1388530800,"objectID":"6f7fd8a4b85155b7f834bfc0f76527d5","permalink":"https://nkrvavica.github.io/publication/travavs-2014-spectral/","publishdate":"2014-01-01T00:00:00+01:00","relpermalink":"/publication/travavs-2014-spectral/","section":"publication","summary":"","tags":null,"title":"Spectral and Monochromatic Approach to the Definition of Hydrodynamic Load on Vertical Piles","type":"publication"},{"authors":["Nino Krvavica","Boris Mofardin","Igor Ružić","́ Nevenka Ožanić"],"categories":null,"content":"","date":1325372400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1325372400,"objectID":"a5ca583d1e31399d095f33f85b4f38f6","permalink":"https://nkrvavica.github.io/publication/krvavica-2012-mjerenje/","publishdate":"2012-01-01T00:00:00+01:00","relpermalink":"/publication/krvavica-2012-mjerenje/","section":"publication","summary":"","tags":null,"title":"Measurement and analysis of salinization at the Rječina estuary","type":"publication"},{"authors":["Vanja Travaš","Nino Krvavica","Ivana Radman"],"categories":null,"content":"","date":1325372400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1325372400,"objectID":"cf5b2f23493bd8ed56b3eee774a59f07","permalink":"https://nkrvavica.github.io/publication/travavs-2012-numerical/","publishdate":"2012-01-01T00:00:00+01:00","relpermalink":"/publication/travavs-2012-numerical/","section":"publication","summary":"","tags":null,"title":"Numerical analysis of hysteresis in rating curves for open channel flow","type":"publication"}]